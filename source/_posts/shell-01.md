---
layout: post
title: Shell 最佳实践
date: 2020-06-17
tags: blog
---

# Shell 脚本最佳实践

## 代码风格规范

### 开头有 "蛇棒"

* 所谓的 shebang 其实就是在很多脚本的第一行出现的 `#!` 开头的注释

* 它指明了当我们没有指定解释器的时候，默认的解释器，一般是如下显示

```sh
#!/bin/bash
```

<!-- more -->

---

* 解释器有很多种，除了 bash 外，我们可以使用如下命令进行查看

```sh
cat /etc/shalls
```

* 如果我们的 shell 脚本没有指定 shebang，则会使用系统变量 `$SHELL` 指定的值

### 代码有注释

* 注释的一样不仅在于解释用途，而在于告诉我们注意事项，就像是一个 README

* 具体来说，对于 shell 脚本，注释一般包括下面几个部分

   * shebang

   * 脚本的参数

   * 脚本的用途

   * 脚本的注意事项

   * 脚本的写作时间，作者，版权等

   * 各个函数前的说明注释

   * 一些较复杂的单行命令注释

### 参数要规范

* 当我们的脚本需要接受参数的时候，我们一定要先判断参数是否合乎规范，并给出合适的回显，方便使用者了解参数的使用。

    * 如判断参数的个数

```sh
if [[ $# != 2 ]];then
    echo "Parameter incorrect."
    exit 1
fi
```

### 变量

* 一般情况下我们会将一些重要的环境变量定义在开头，确保这些变量的存在。

```sh
source /etc/profile
export PATH="/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/apps/bin/"
```

* 这种定义方式有一个很常见的用途，最典型的应用就是，当我们本地安装了很多java版本时，我们可能需要指定一个java来用。

* 那么这时我们就会在脚本开头重新定义JAVA_HOME以及PATH变量来进行控制。

### 缩进有规矩

* 常见的缩进方法主要有”soft tab”和”hard tab”两种。

    * 所谓soft tab就是使用n个空格进行缩进(n通常是2或4)

    * 所谓hard tab当然就是指真实的\t字符（推荐）

    * 对于 if 和 for 语句之类的，我们最好不要把then，do 这些关键字单独写一行，这样看上去比较丑

```sh
for a in {1..10}; do
    echo "$a"
done
```

### 命名有规范

* 所谓命名规范，基本包含下面这几点：

    * 文件名规范，以.sh结尾，方便识别

    * 变量名字要有含义，不要拼错

    * 统一命名风格，写shell一般用小写字母加下划线

### 跨平台问题

* 对于跨平台写脚本还有一个比较常见的问题就是换行符不同。windows默认是 `\r\n` 而 unix 下是 `\n`。

* 不过有两个小工具可以非常方便的解决这个问题：

    * dos2unix
    * unix2dos

### 执行权限

* 虽然 shell 可以直接使用 bash 执行，但是还是推荐添加 `x` 权限好

### 日志和回显

* 如果这个脚本是供用户直接在命令行使用的，那么我们最好还要能够在执行时实时回显执行过程，方便用户掌控。

### 密码要移除

* 不要把密码硬编码在脚本里，尤其是 GitHub 这类平台

### 太长要分行

```sh
./configure \
–prefix=/usr \
–sbin-path=/usr/sbin/nginx \
–conf-path=/etc/nginx/nginx.conf \
```

---

* 注意反斜杠前有个空格

## 编码细节规范

### 代码有效率

* 在使用命令的时候要了解命令的具体做法，尤其当数据处理量大的时候，要时刻考虑该命令是否会影响效率

### 勤用双引号

* 在使用 `$` 来获取变量的时候最好加上双引号

### 巧用 main 函数

* 我们知道，像 java，C 这样的编译型语言都会有一个函数入口，这种结构使得代码可读性很强，我们知道哪些直接执行，那些是函数。

* 但是脚本不一样，脚本属于解释性语言，从第一行直接执行到最后一行，如果在这当中命令与函数糅杂在一起，那就非常难读了。

* 我们可以使用如下代码，实现诸如 Python 的 main 函数

```sh
func1(){
    #do sth
}

func2(){
    #do sth
}

main(){
    func1
    func2
}

main "$@"
```

---

* "$@" 为传递给 shell 脚本的所有参数的列表

### 考虑作用域

* shell 中默认的变量作用域都是全局的，因此，相比直接使用全局变量
  
* 我们最好使用 `local`，`readonly` 这类的命令

* 其次我们可以使用 `declare` 来声明变量

### 函数返回值

* 在使用函数的时候一定要注意，shell 中函数的返回值只能是 int，所以一般都是 0 或 1 就够了

* 但是如果想返回 str，可以使用如下方法进行变通

```sh
func(){
    echo "2333"
}

res=$(func)
echo "func return str is $res."
```

### 间接引用值

* 在变量名前加一个 `!` 就可以做到简单的间接引用值了

```sh
VAR1="2323232"
VAR2=${!VAR1}
```

---

* 不过需要注意的是，用上面的方法，我们只能够做到取值，而不能做到赋值

* 如果想要做到赋值，还是老老实实的用 eval 来处理

```sh
VAR1=VAR2
eval $VAR1=233
echo $VAR2
```

### heredocs

* 所谓 heredocs，是一种多行输入的方法，即在 "<<" 后定义一个标识符，接着我们可以输入多行内容，直到再次遇到标识符为止

    * 注意，输入的值如果有变量需要添加 `\` 转义

```sh
cat >> demo.sh <<A
My shell is \$SHELL
A
```

### 学会查路径

* 通常我们会直接使用 pwd 来获取脚本的路径，但是这样其实是不严谨的

    *  pwd 获取的是当前 shell 的执行路径，而不是当前脚本的执行路径。

* 正确的做法应该是如下两种之一

```sh
script_dir=$(cd $(dirname $0) && pwd)
script_dir=$(dirname $(readlink -f $0 ))
```

### 命令并行化

* 当我们需要充分考虑执行效率时，我们可能需要在执行命令的时候考虑并行化。

* shell中最简单的并行化是通过 `&` 以及 `wait` 命令来做:

    * wait是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。
    * 使用 wait 可以在 bash 脚本“多进程”执行模式下，起到一些特殊控制的作用。

```sh
func(){
    #do sth
｝
for ((i=0;i<10;i++)); do
    func &
done
wait
```

###  全文本搜索

* 我们知道，当我们想在文件夹下所有的 txt 文件中检索某一个 str 时，可能会到类似如下的命令

```sh
find . -name "*.txt" -type f | xargs grep str
```

* 但是有两个小问题需要我们注意

1. 如果文件名包含空格，该如何处理

```sh
find . -type f | xargs -i echo "{}" | xargs grep str
# xargs -i 可以使用 "{}" 来指代接收的参数
```

2. 有时候，文件的字符集可能跟终端的字符集不一致，导致 grep 在搜索时将文件当成二进制文件处理，此时我们需要使用 grep -a 来声明说也对二进制文件进行匹配

```sh
find . -type f | xargs grep -a str
```

### 新的写法

* 尽量使用 func(){} 来定义函数

* 尽量使用 [[]] 来替代 []

* 尽量使用 $() 将命令的结果赋值给变量，而不是反引号

* 在复杂的场景下，尽量使用 printf 代替 echo 进行回显

### 其他

* 路径尽量保持绝对路径，绝多路径不容易出错，如果非要用相对路径，最好用 `./` 修饰

* 优先使用 bash 的变量替换代替 awk sed，这样更加简短

* 简单的 if 尽量使用 && 和 ||，写成单行。

```sh
[[ x > 2]] && echo x
```

* 当 export 变量时，尽量加上子脚本的 namespace，保证变量不冲突

* 会使用 trap 捕获信号，并在接受到终止信号时执行一些收尾工作

* 使用 mktemp 生成临时文件或文件夹

* 利用 /dev/null 过滤不友好的输出信息

* 会利用命令的返回值 ($?) 判断命令的执行情况

* 使用文件前要判断文件是否存在，否则做好异常处理

* 不要处理 ls 后的数据 (如 ls -l | awk '{ print $8 }')，ls 的结果非常不确定，并且平台有关

* 读取文件时不要使用 for loop 而要使用 while read

* 使用 cp -r 命令复制文件夹的时候要注意如果目的文件夹不存在则会创建，如果存在则会复制到该文件的子文件夹下

## 相关链接

[url](https://mp.weixin.qq.com/s/JtT8VaU7mumQSytkuw2ieQ)

